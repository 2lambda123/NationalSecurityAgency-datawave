package nsa.datawave.query.tables.chunk;

import java.util.Iterator;
import java.util.Set;
import java.util.Map.Entry;

import nsa.datawave.query.tables.shard.ShardQueryTable;
import nsa.datawave.webservice.query.Query;
import nsa.datawave.webservice.query.configuration.GenericQueryConfiguration;

import org.apache.accumulo.core.client.Connector;
import org.apache.accumulo.core.data.Key;
import org.apache.accumulo.core.data.Value;
import org.apache.accumulo.core.security.Authorizations;
import org.apache.log4j.Logger;

/**
 * A query logic that transforms a Query object into pieces and runs them in sequence. Clients should inject an instance of <code>Chunker</code> that provides
 * an interface to iterate over the resulting sub queries.
 */
public class PartitionedQueryTable extends ShardQueryTable {
    private static final Logger log = Logger.getLogger(PartitionedQueryTable.class);
    
    private Connector connector;
    private Query settings;
    private Set<Authorizations> auths;
    
    // intended to be injected via spring
    private Chunker chunker;
    
    public PartitionedQueryTable() {
        super();
    }
    
    public PartitionedQueryTable(PartitionedQueryTable other) {
        super(other);
        this.setChunker(other.chunker.clone());
    }
    
    /**
     * This logic will save the supplised authorizations and connection. The query will be passed as the base query to the chunker and then attempt to process
     * the first chunk.
     */
    @Override
    public GenericQueryConfiguration initialize(Connector connection, Query settings, Set<Authorizations> auths) throws Exception {
        log.trace("initialize()");
        
        this.connector = connection;
        this.auths = auths;
        
        this.settings = settings.duplicate(settings.getQueryName() + "-chunk");
        chunker.setBaseQuery(this.settings);
        
        return initializeNextChunk();
    }
    
    /**
     * This method will pull the next sub-query from the chunker and use that query to reinitialize the query logic.
     */
    public GenericQueryConfiguration initializeNextChunk() throws Exception {
        log.trace("initializeNextChunk()");
        Query settings = chunker.next();
        return super.initialize(this.connector, settings, this.auths);
    }
    
    /**
     * Returns the iterator exposed by the ShardQueryLogic chain. This is used to construct the
     * 
     * @return
     */
    private Iterator<Entry<Key,Value>> scanIterator() {
        return super.iterator();
    }
    
    /**
     * Returns an iterator to the results of every sub-query generated by the specified chunker.
     * 
     * This iterator will re-initialize the query logic when moving between the generated query chunks.
     * 
     */
    @Override
    public Iterator<Entry<Key,Value>> iterator() {
        return new Iterator<Entry<Key,Value>>() {
            Iterator<Entry<Key,Value>> currentChunk = scanIterator();
            
            @Override
            public boolean hasNext() {
                while (chunker.hasNext() && !currentChunk.hasNext()) {
                    try {
                        GenericQueryConfiguration nextConfig = initializeNextChunk();
                        setupQuery(nextConfig);
                        this.currentChunk = scanIterator();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    } catch (Exception e) {
                        log.warn("Could not process a chunk.", e);
                    }
                }
                return currentChunk.hasNext();
            }
            
            @Override
            public Entry<Key,Value> next() {
                return this.currentChunk.next();
            }
            
            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }
            
        };
    }
    
    @Override
    public PartitionedQueryTable clone() {
        return new PartitionedQueryTable(this);
    }
    
    public Chunker getChunker() {
        return chunker;
    }
    
    public void setChunker(Chunker chunker) {
        this.chunker = chunker;
    }
}
